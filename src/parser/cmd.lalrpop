use crate::parser::ast::*;
use lalrpop_util::ErrorRecovery;

grammar();

extern {
    type Location = usize;
    type Error = (usize, usize);

    enum ASTKind {
        "&" => ASTKind::Ampersand,
        "|" => ASTKind::Pipe,
        ";" => ASTKind::SemiColon,
        "$" => ASTKind::Dollar,
        "(" => ASTKind::OpenParen,
        ")" => ASTKind::CloseParen,
        "{" => ASTKind::OpenBrace,
        "}" => ASTKind::CloseBrace,
        "number" => ASTKind::NumberLiteral,
        "." => ASTKind::Dot,
        "," => ASTKind::Comma,
        "literal" => ASTKind::Literal,
        "identifier" => ASTKind::Identifier,
        "\"" => ASTKind::DoubleQuote,
        "error" => ASTKind::Error,
    }
}

pub Delimited : ASTNode = {
    <ll: @L> <left: Delimited> <pipe: Node<SemiColon>> <right: Sequenced> <rr: @R> =>
         ASTNode::new_simple(ll, rr, Sequenced::new(), vec![left, pipe, right]),
     <Sequenced>
}

Sequenced : ASTNode = {
    <ll: @L> <left: Sequenced> <pipe: Node<Ampersand>> <right: Piped> <rr: @R> =>
         ASTNode::new_simple(ll, rr, Sequenced::new(), vec![left, pipe, right]),
     <Piped>
}

Piped : ASTNode = {
    <ll: @L> <left: Piped> <pipe: Node<Pipe>> <right: CommandOrFunction> <rr: @R> =>
         ASTNode::new_simple(ll, rr, Piped::new(), vec![left, pipe, right]),
     <CommandOrFunction>
}

CommandOrFunction : ASTNode = {<NodeParent<Command>>, <NodeParent<Function>>}

Command : (Command, Vec<ASTNode>) = {
    <name: Node<CommandName>> <args: NodeParent<CommandArguments>> => {
        (Command::new(), vec![name, args])
    },
    <ll: @L><err: !><rr: @R> => (Command::new(), vec![ASTNode::new_simple(ll, rr, ASTError::new(CommandName::new(), err), vec![])])
}
CommandName : CommandName = {
    <l: Literal> => CommandName::new()
}
CommandArguments : (CommandArguments, Vec<ASTNode>) = {
    <v: Node<Literal>*> => {
        (CommandArguments::new(), v)
    }
}

Delimeter : ASTNode = {
    <Node<SemiColon>>, <Node<Pipe>>, <Node<Ampersand>>
}

Function : (Function, Vec<ASTNode>) = {
    <dollar: Node<Dollar>> <chain: Value> => (Function::new(), vec![dollar, chain]),
    <dollar: Node<Dollar>> <ll: @L><err: !><rr: @R> => (Function::new(), vec![dollar, ASTNode::new_simple(ll, rr, ASTError::new(PropertyName::new(), err), vec![])])
}

pub CallChain : ASTNode = {
    <ll: @L> <l: Value> <d: Node<Dot>> <call: NodeParent<PropertyCall>> <rr: @R> => {
        ASTNode::new_simple(ll, rr, CallChain::new(), vec![l, d, call])
     },
     <NodeParent<PropertyCall>>
}

pub PropertyCallNode : ASTNode = { <NodeParent<PropertyCall>>}

PropertyCall : (PropertyCall, Vec<ASTNode>) = {
    <name: Node<PropertyName>> <args: NodeParent<ParenthesizedArgumentsList>> => (PropertyCall::new(), vec![name, args]),
    <name: Node<PropertyName>> => (PropertyCall::new(), vec![name]),
}

ParenthesizedArgumentsList : (ParenthesizedArgumentsList, Vec<ASTNode>) = {
    <l: Node<OpenParen>> <args: Value*> <r: Node<CloseParen>> => {
        let mut result = Vec::new();
        result.push(l);
        result.extend(args);
        result.push(r);

        (ParenthesizedArgumentsList::new(), result)
    },

    <l: Node<OpenParen>> <args: Value*> <ll: @L>!<rr: @R> => {
        let mut result = Vec::new();
        result.push(l);
        result.extend(args);
        result.push(ASTNode::new_simple(ll, rr, ASTError::new_artificial(CloseParen::new()), vec![]));

        (ParenthesizedArgumentsList::new(), result)
    }
}


pub Value : ASTNode = {
    <n : StringLiteral> => n,
    <n : Node<NumberLiteral>> => n,
    <n : BracedCommand> => n,
    <n : CallChain> => n,

}

BracedCommand : ASTNode = {
    <ll: @L> <left: Node<OpenBrace>> <delimited: Delimited> <right: Node<CloseBrace>> <rr: @R> => {
        ASTNode::new_simple(ll, rr, BracedCommand::new(), vec![left, delimited, right])
    },
    <ll: @L> <left: Node<OpenBrace>> <delimited: Delimited> <el: @L> <err: !> <er: @R> <rr: @R> => {
        ASTNode::new_simple(ll, rr, BracedCommand::new(), vec![
            left,
            delimited,
            ASTNode::new_simple(el, er, ASTError::new(CloseBrace::new(), err), vec![])]
        )
    },
}


NodeParent<T> : ASTNode = {
 <l: @L> <v: T> <r: @R> => ASTNode::new(Span::new(l, r), v.0.boxed(), v.1),
};
Node<T> : ASTNode = {
 <l: @L> <v: T> <r: @R> => ASTNode::new(Span::new(l, r), v.boxed(), vec![]),
};

Identifier : Identifier = {
    "identifier" => Identifier::new(),
}

Ampersand : Ampersand = {
    "&" => Ampersand::new(),
}

Pipe : Pipe = {
    "|" => Pipe::new(),
}

SemiColon : SemiColon = {
    ";" => SemiColon::new(),
}

Dollar : Dollar = {
    "$" => Dollar::new(),
}

OpenParen : OpenParen = {
    "(" => OpenParen::new(),
}

CloseParen : CloseParen = {
    ")" => CloseParen::new(),
}

OpenBrace : OpenBrace = {
    "{" => OpenBrace::new(),
}

CloseBrace : CloseBrace = {
    "}" => CloseBrace::new(),
}

StringLiteral : ASTNode = {
    <ll: @L> "\"" Literal "\"" <rr: @R> => ASTNode::new_simple(ll, rr, StringLiteral::new(), vec![]),
    <ll: @L> "\"" Literal <e: !> <rr: @R> => ASTNode::new_simple(ll, rr, ASTError::new(StringLiteral::new(), e), vec![]),
}

PropertyName : PropertyName = {
    "identifier" => PropertyName::new(),
}

NumberLiteral : NumberLiteral = {
    "number" => NumberLiteral::new(),
}

Dot : Dot = {
    "." => Dot::new(),
}

Literal : Literal = {
    "literal" => Literal::new(),
}

