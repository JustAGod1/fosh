use crate::parser::ast::*;
use lalrpop_util::ErrorRecovery;

grammar();

extern {
    type Location = usize;
    type Error = (usize, usize);

    enum ASTKind {
        "&" => ASTKind::Ampersand,
        "|" => ASTKind::Pipe,
        ";" => ASTKind::SemiColon,
        "$" => ASTKind::Dollar,
        "(" => ASTKind::OpenParen,
        ")" => ASTKind::CloseParen,
        "{" => ASTKind::OpenBrace,
        "}" => ASTKind::CloseBrace,
        "string" => ASTKind::StringLiteral,
        "number" => ASTKind::NumberLiteral,
        "." => ASTKind::Dot,
        "," => ASTKind::Comma,
        "literal" => ASTKind::Literal,
        "identifier" => ASTKind::Identifier,
    }
}

pub Delimited : ASTNode = {

    <ll: @L> <v: SequencedWithSemicolon+> <rr: @R> => {
        ASTNode::new_simple(ll, rr, CommandLine::new(), v.into_iter().flatten().collect())
    },
    <Sequenced>
}


SequencedWithSemicolon : Vec<ASTNode> = {
    <e: Sequenced> <s: Node<SemiColon>> => {
        vec![e,s]
    }
}

Sequenced : ASTNode = {
    <ll: @L> <left: Sequenced> <pipe: Node<Ampersand>> <right: Piped> <rr: @R> =>
         ASTNode::new_simple(ll, rr, Sequenced::new(), vec![left, pipe, right]),
     <Piped>
}

Piped : ASTNode = {
    <ll: @L> <left: Piped> <pipe: Node<Pipe>> <right: CommandOrFunction> <rr: @R> =>
         ASTNode::new_simple(ll, rr, Piped::new(), vec![left, pipe, right]),
     <CommandOrFunction>
}

CommandOrFunction : ASTNode = {<NodeParent<Command>>, <NodeParent<Function>>}

Command : (Command, Vec<ASTNode>) = {
    <name: Node<CommandName>> <args: NodeParent<CommandArguments>> => {
        (Command::new(), vec![name, args])
    },
    <ll: @L><err: !><rr: @R> => (Command::new(), vec![ASTNode::new_simple(ll, rr, ASTError::new(ASTKind::CommandName, err), vec![])])
}
CommandName : CommandName = {
    <l: Literal> => CommandName::new()
}
CommandArguments : (CommandArguments, Vec<ASTNode>) = {
    <v: Node<Literal>*> => {
        (CommandArguments::new(), v)
    }
}

Delimeter : ASTNode = {
    <Node<SemiColon>>, <Node<Pipe>>, <Node<Ampersand>>
}

Function : (Function, Vec<ASTNode>) = {
    <dollar: Node<Dollar>> <chain: CallChain> => (Function::new(), vec![dollar, chain])
}

CallChain : ASTNode = {
    <ll: @L> <l: CallChain> <d: Node<Dot>> <call: NodeParent<PropertyCall>> <rr: @R> => {
        ASTNode::new_simple(ll, rr, CallChain::new(), vec![l, d, call])
     },
     <call: NodeParent<PropertyCall>> => call
}

PropertyCall : (PropertyCall, Vec<ASTNode>) = {
    <name: Node<PropertyName>> => (PropertyCall::new(), vec![name]),
    <name: Node<PropertyName>> <args: NodeParent<ParenthesizedArgumentsList>> => (PropertyCall::new(), vec![name, args]),
    <ll: @L><error: !><rr: @R> => (PropertyCall::new(), vec![
         ASTNode::new_simple(ll, rr, ASTError::new(ASTKind::PropertyName, error), vec![])
         ]),
}

ParenthesizedArgumentsList : (ParenthesizedArgumentsList, Vec<ASTNode>) = {
    <l: Node<OpenParen>> <args: Value*> <r: Node<CloseParen>> => {
        let mut result = Vec::new();
        result.push(l);
        result.extend(args);
        result.push(r);

        (ParenthesizedArgumentsList::new(), result)
    },

    <l: Node<OpenParen>> <args: Value*> <ll: @L><err: !><rr: @R> => {
        let mut result = Vec::new();
        result.push(l);
        result.extend(args);
        result.push(ASTNode::new_simple(ll, rr, ASTError::new(ASTKind::CloseParen, err), vec![]));

        (ParenthesizedArgumentsList::new(), result)
    }
}


Value : ASTNode = {
    <n : Node<StringLiteral>> => n,
    <n : Node<NumberLiteral>> => n,
    <n : Node<Identifier>> => n
}


NodeParent<T> : ASTNode = {
 <l: @L> <v: T> <r: @R> => ASTNode::new(Span::new(l, r), v.0.boxed(), v.1),
};
Node<T> : ASTNode = {
 <l: @L> <v: T> <r: @R> => ASTNode::new(Span::new(l, r), v.boxed(), vec![]),
};

Identifier : Identifier = {
    "identifier" => Identifier::new(),
}

Ampersand : Ampersand = {
    "&" => Ampersand::new(),
}

Pipe : Pipe = {
    "|" => Pipe::new(),
}

SemiColon : SemiColon = {
    ";" => SemiColon::new(),
}

Dollar : Dollar = {
    "$" => Dollar::new(),
}

OpenParen : OpenParen = {
    "(" => OpenParen::new(),
}

CloseParen : CloseParen = {
    ")" => CloseParen::new(),
}

OpenBrace : OpenBrace = {
    "{" => OpenBrace::new(),
}

CloseBrace : CloseBrace = {
    "}" => CloseBrace::new(),
}

StringLiteral : StringLiteral = {
    "string" => StringLiteral::new(),
}

PropertyName : PropertyName = {
    "identifier" => PropertyName::new(),
}

NumberLiteral : NumberLiteral = {
    "number" => NumberLiteral::new(),
}

Dot : Dot = {
    "." => Dot::new(),
}

Literal : Literal = {
    "literal" => Literal::new(),
}

